// Generated by CoffeeScript 2.7.0
(function() {
  var activate, closebyfspath, deactivate, docdic, escapeHtml, fjoin, fname, handleclose, handlesavefile, marker, odog, openCustomDocument, openEditor, processYeFile, readFileAsync, recordfile, resolveCustomEditor, tmpdir, updateWebview, vscode, webviewdic, writeFileAsync, yefamily;

  vscode = require('vscode');

  ({tmpdir} = require('os'));

  ({
    readFile: readFileAsync,
    writeFile: writeFileAsync
  } = require('fs').promises);

  ({
    // import { basename as fname, join as fjoin } from 'path';
    basename: fname,
    join: fjoin
  } = require('path'));

  // 分隔符
  marker = '# -----昭-----';

  // ye文件映射表
  yefamily = {};

  // doc映射表
  docdic = {};

  // webview映射表
  webviewdic = {};

  // 调试通道
  odog = null;

  activate = function(context) {
    var cep, disposable, otC, saveListener, tabCloseListener;
    // 创建输出通道
    otC = vscode.window.createOutputChannel('贱狗');
    context.subscriptions.push(otC);
    odog = function(msg) {
      var time;
      time = new Date().toLocaleTimeString();
      otC.appendLine(`[${time}] ${msg}`);
      return console.log(`[贱狗${time}]: ${msg}`);
    };
    odog('KeyDog 插件已激活');
    disposable = vscode.commands.registerCommand('cofee.helloWorld', function() {
      return vscode.window.showInformationMessage('H道动!');
    });
    context.subscriptions.push(disposable);
    
    // 注册自定义编辑器
    cep = vscode.window.registerCustomEditorProvider('贱狗.编辑器', {openCustomDocument, resolveCustomEditor});
    context.subscriptions.push(cep);
    odog('注册自定义编辑器成功');
    // 监听保存事件
    saveListener = vscode.workspace.onDidSaveTextDocument(async function(doc) {
      var fsPath;
      fsPath = doc.uri.fsPath;
      if (fsPath in yefamily) {
        return (await handlesavefile(fsPath));
      }
    });
    // 只需要在插件卸载时清理一次
    context.subscriptions.push(saveListener);
    odog('注册保存事件监听成功');
    // 全局Tab关闭事件监听
    tabCloseListener = vscode.workspace.onDidCloseTextDocument(async function(doc) {
      var fsPath;
      
      // 处理关闭事件
      odog(`处理关闭事件: ${doc.uri.fsPath}`);
      odog(`处理关闭事件yefamily[fsPath]: ${yefamily[fsPath]}`);
      fsPath = doc.uri.fsPath;
      if (fsPath in yefamily) {
        await handlesavefile(fsPath);
        return (await handleclose(fsPath));
      }
    });
    odog('注册关闭事件监听成功');
    
    // 注册销毁
    return context.subscriptions.push(tabCloseListener);
  };

  deactivate = function() {};

  module.exports = {activate, deactivate};

  handlesavefile = async function(fsPath) {
    var brocon, brother, dad, dadcon, isright, mycon, ref, ref1;
    odog(`保存文件开始: ${fsPath}`);
    ({dad, brother, isright} = yefamily[fsPath]);
    brocon = (ref = docdic[brother]) != null ? ref.getText() : void 0;
    mycon = (ref1 = docdic[fsPath]) != null ? ref1.getText() : void 0;
    if (!((brocon != null) && (mycon != null))) {
      odog("兄弟或我的内容不存在, 无法保存");
      return;
    }
    dadcon = isright ? mycon + marker + brocon : brocon + marker + mycon;
    await writeFileAsync(dad, dadcon, 'utf8');
    odog(`保存文件: ${fname(dad)}`);
    await updateWebview(dad);
    return odog(`更新webview: ${fname(dad)}`);
  };

  handleclose = function(fsPath) {
    var brother, dad, isright;
    // 处理关闭事件
    odog(`处理handleclose: ${fname(fsPath)}`);
    ({dad, brother, isright} = yefamily[fsPath]);
    delete yefamily[fsPath];
    delete yefamily[brother];
    closebyfspath(dad);
    odog(`关闭父文件: ${fname(dad)}`);
    closebyfspath(brother);
    return odog(`关闭兄弟文件: ${fname(brother)}`);
  };

  closebyfspath = function(fspath) {
    var target;
    target = vscode.window.tabGroups.all.flatMap(function(group) {
      return group.tabs;
    }).find(function(t) {
      var ref, ref1;
      return ((ref = t.input) != null ? (ref1 = ref.uri) != null ? ref1.fsPath : void 0 : void 0) === fspath;
    });
    if (target != null) {
      vscode.window.tabGroups.close(target);
    }
    return odog(`关闭文件: ${fname(fspath)}, 存在: ${target != null}`);
  };

  
  // 平铺函数1：创建文档
  openCustomDocument = function(uri) {
    return {
      // 在 CoffeeScript 中，函数最后一行自动返回
      uri: uri, // 给resolve用的uri
      dispose: function() {} // 销毁的回调
    };
  };

  
  // 平铺函数3：处理编辑器
  resolveCustomEditor = async function(webviewdoc, webviewPanel) {
    var yepath;
    yepath = webviewdoc.uri.fsPath;
    webviewdic[yepath] = {webviewdoc, webviewPanel};
    // 初始显示
    await updateWebview(yepath);
    // 监听保存事件, 虽然每个文档都注册一遍, 但是, 他们是同一个事件.
    // *  这个可以正常使用, 直接把分栏注册在onWillSaveTextDocument就OK了.
    // * 还是拿出去更合理, 因为他其实只是更新webview展示
    // saveListener = vscode.workspace.onDidSaveTextDocument (doc) ->
    //   if doc.uri.fsPath is webviewdoc.uri.fsPath
    //     updateWebview webviewPanel, webviewdoc

    // * 这个也很关键, 他会自动销毁注册的listener, 哈哈哈, 完美
    // webviewPanel.onDidDispose -> saveListener.dispose()
    // 直接打开我们的分栏
    odog('KeyDog 可以操作了');
    return processYeFile(webviewdoc);
  };

  // 第一步, 更新 webview 内容, 并且赋值webviewdoc.content
  updateWebview = async function(yepath) {
    var error, webviewPanel, webviewdoc;
    ({webviewPanel, webviewdoc} = webviewdic[yepath]);
    if (!((webviewPanel != null) && (webviewdoc != null))) {
      odog("webviewPanel 或 webviewdoc 不存在, 无法更新");
      return;
    }
    try {
      webviewdoc.content = (await readFileAsync(yepath, 'utf8'));
      return webviewPanel.webview.html = `<h1> 贱狗只读展示, 请于分栏编辑文件: ${fname(yepath)}</h1>
<p><small>Updated: ${new Date().toLocaleTimeString()}</small></p>
<pre>${escapeHtml(webviewdoc.content)}</pre>`;
    } catch (error1) {
      error = error1;
      odog(`更新 webview 失败: ${error}`);
      return vscode.window.showErrorMessage(`更新 webview 失败: ${error}`);
    }
  };

  // HTML 转义函数
  escapeHtml = function(text) {
    return text.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('"', '&quot;').replaceAll("'", '&#39;');
  };

  // 第二步, 处理webviewdoc.content
  processYeFile = async function(webviewdoc) {
    var error, fileId, fileName, left, leftPath, right, rightPath, tempDir;
    fileId = webviewdoc.uri.fsPath;
    fileName = fname(fileId);
    odog(`处理文件: ${fileName}`);
    try {
      
        // 解析内容
      [right, ...left] = webviewdoc.content.split(marker);
      left = left.join(marker);
      // 创建临时文件
      tempDir = tmpdir();
      leftPath = fjoin(tempDir, `${fileName}_left.md`);
      rightPath = fjoin(tempDir, `${fileName}_right.md`);
      
      // 并行异步写入两个文件
      await Promise.all([writeFileAsync(leftPath, left, 'utf8'), writeFileAsync(rightPath, right, 'utf8')]);
      odog(`创建临时文件: ${fname(leftPath)}, ${fname(rightPath)}`);
      
      // 记录活动文件
      recordfile({
        dad: fileId,
        left: leftPath,
        right: rightPath
      });
      
      // 分栏打开临时文件
      // ✅ 用数组字面量 + Promise.all
      await Promise.all([
        openEditor({
          filePath: leftPath,
          viewColumn: vscode.ViewColumn.One,
          preserveFocus: true
        }),
        openEditor({
          filePath: rightPath,
          viewColumn: vscode.ViewColumn.Two,
          preserveFocus: false
        })
      ]);
      return odog('已打开临时文件分栏');
    } catch (error1) {
      error = error1;
      odog(`处理文件失败: ${fileName} - ${error}`);
      return vscode.window.showErrorMessage(`处理文件失败: ${error}`);
    }
  };

  // * 更新yefamily
  recordfile = function({dad, left, right}) {
    yefamily[left] = {
      dad,
      brother: right,
      isright: false
    };
    yefamily[right] = {
      dad,
      brother: left,
      isright: true
    };
    // * 虽然简洁, 但是, 不如上面直白
    // yefamily[s]={dad, brother:twin[1-i] } for s,i in twin
    // 记录活动文件
    return odog(`记录活动文件: ${fname(dad)}, ${fname(left)}, ${fname(right)}`);
  };

  openEditor = async function({filePath, viewColumn, preserveFocus}) {
    var doc, editor, error, uri;
    try {
      uri = vscode.Uri.file(filePath);
      doc = (await vscode.workspace.openTextDocument(uri));
      editor = (await vscode.window.showTextDocument(doc, {viewColumn, preserveFocus}));
      // 全局docdic
      docdic[filePath] = doc;
      return odog(`打开编辑器: ${fname(filePath)}`);
    } catch (error1) {
      error = error1;
      return odog(`打开编辑器失败: ${fname(filePath)} - ${error}`);
    }
  };

}).call(this);
