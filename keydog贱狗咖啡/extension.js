// Generated by CoffeeScript 2.7.0
(function() {
  var activate, ddog, deactivate, docdic, escapeHtml, fjoin, fname, handleclose, handlesavefile, marker, odog, openCustomDocument, openEditor, recordfile, resolveCustomEditor, tmpdir, updateWebview, vscode, webviewdic, writeFileAsync, yefamily;

  vscode = require('vscode');

  ({
    basename: fname,
    join: fjoin
  } = require('path'));

  // 需要添加
  ({tmpdir} = require('os'));

  ({
    writeFile: writeFileAsync
  } = require('fs').promises);

  marker = '# -----昭-----';

  // ye文件映射表
  yefamily = {};

  // doc映射表
  docdic = {};

  // webview映射表
  webviewdic = {};

  // 调试通道
  odog = null;

  ddog = null;

  activate = function(context) {
    var cep, disposable, hotExitSetting, otC, reasons, saveListener, tabCloseListener;
    // 创建输出通道
    otC = vscode.window.createOutputChannel('贱狗');
    context.subscriptions.push(otC);
    odog = function(msg) {
      var time;
      time = new Date().toLocaleTimeString();
      otC.appendLine(`[${time}] ${msg}`);
      return console.log(`[贱狗${time}]: ${msg}`);
    };
    ddog = function(msg) {
      var time;
      time = new Date().toLocaleTimeString();
      otC.appendLine(`[${time}] [调试] ${JSON.stringify(msg)}`);
      return console.log(`[贱狗${time}][调试]: ${JSON.stringify(msg)}`);
    };
    odog('KeyDog 插件已激活');
    reasons = ['未知', '人工保存', '自动保存', '失焦保存'];
    context.subscriptions.push(vscode.workspace.onDidCloseTextDocument(function(doc) {
      return odog(`DidClose: ${vscode.workspace.asRelativePath(doc.fileName)}`);
    }), vscode.window.onDidChangeActiveTextEditor(function(editor) {
      var name;
      name = editor && (editor.document.uri.scheme === 'file' ? vscode.workspace.asRelativePath(editor.document.fileName) : `[${editor.document.uri.scheme}]`) || 'none';
      return odog(`DidChangeActive: ${name}`);
    }), vscode.window.onDidChangeVisibleTextEditors(function(es) {
      var e, names;
      names = ((function() {
        var j, len, results;
        if (e.document.uri.scheme === 'file') {
          return fname(e.document.fileName);
        } else {
          results = [];
          for (j = 0, len = es.length; j < len; j++) {
            e = es[j];
            results.push(`[${e.document.uri.scheme}]`);
          }
          return results;
        }
      })()).join(',');
      return odog(`DidChangeVisible: ${names}`);
    }), vscode.workspace.onWillSaveTextDocument(function(e) {
      return odog(`WillSave: ${reasons[e.reason] || e.reason}: ${vscode.workspace.asRelativePath(e.document.fileName)}`);
    }), vscode.workspace.onDidSaveTextDocument(function(doc) {
      return odog(`DidSave: ${vscode.workspace.asRelativePath(doc.fileName)}`);
    }), vscode.workspace.onDidOpenTextDocument(function(doc) {
      var name;
      name = doc.uri.scheme === 'file' ? fname(doc.fileName) : `[${doc.uri.scheme}]`;
      return odog(`DidOpen: ${name}`);
    }), vscode.window.onDidChangeTextEditorViewColumn(function(e) {
      return odog(`DidChangeViewColumn: ${fname(e.textEditor.document.fileName)} -> 第${e.textEditor.viewColumn}栏`);
    }), vscode.window.onDidChangeTextEditorOptions(function(e) {
      return odog(`DidChangeOptions: ${fname(e.textEditor.document.fileName)}`);
    }), vscode.window.onDidChangeWindowState(function(e) {
      return odog(`DidChangeWindowState: focused=${e.focused}`);
    }), vscode.window.tabGroups.onDidChangeTabs(function(e) {
      return odog(`onDidChangeTabs: focused=${e.closed.length}`);
    }));
    disposable = vscode.commands.registerCommand('cofee.helloWorld', function() {
      return vscode.window.showInformationMessage('H道动!');
    });
    context.subscriptions.push(disposable);
    // 验证热退出
    hotExitSetting = vscode.workspace.getConfiguration('files').get('hotExit');
    odog(`当前热退出设置: ${hotExitSetting}`);
    // 注册自定义编辑器
    cep = vscode.window.registerCustomEditorProvider('贱狗.编辑器', {openCustomDocument, resolveCustomEditor});
    context.subscriptions.push(cep);
    odog('注册自定义编辑器成功');
    
    // 监听保存事件
    saveListener = vscode.workspace.onDidSaveTextDocument(async function(doc) {
      var content, dad, fsPath;
      odog('保存事件: 开始');
      fsPath = doc.uri.fsPath;
      odog(`保存事件: path: ${fname(fsPath)}`);
      if (!(fsPath in yefamily)) {
        odog(`保存事件: ${fname(fsPath)}, 不是贱狗文件, 跳过`);
        return;
      }
      content = (await handlesavefile(fsPath));
      ({dad} = yefamily[fsPath]);
      await updateWebview(dad, content);
      return odog(`更新webview: ${fname(dad)}`);
    });
    // 只需要在插件卸载时清理一次
    context.subscriptions.push(saveListener);
    odog('注册保存事件监听成功');
    // 全局Tab关闭事件监听
    tabCloseListener = vscode.workspace.onDidCloseTextDocument(function(doc) {
      var i;
      
      // 处理关闭事件
      odog('关闭事件: 开始');
      // fsPath = doc.uri.fsPath
      // odog "关闭事件: path: #{fname fsPath}"
      // odog "关闭事件: yefamily[fsPath]: #{yefamily[fsPath]}"
      // unless fsPath of yefamily
      //  odog "关闭事件:跳过: #{fname fsPath}, 不是贱狗文件, 跳过"
      //  return
      return odog(`关闭事件: 匹配字典:${(function() {
        var j, len, ref, results;
        ref = Object.keys(yefamily);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          results.push(fname(i));
        }
        return results;
      })()}`);
    });
    // await handlesavefile fsPath
    // await handleclose fsPath 
    odog('关闭事件: 监听成功');
    // 在第79行后添加这些行
    odog(`关闭事件监听器类型: ${typeof tabCloseListener}`);
    odog(`监听器对象存在: ${tabCloseListener != null}`);
    
    // 注册销毁
    return context.subscriptions.push(tabCloseListener);
  };

  deactivate = function() {};

  module.exports = {activate, deactivate};

  handlesavefile = function(fsPath) {
    return odog(`保存文件: 开始: ${fsPath}`);
  };

  handleclose = function(fsPath) {
    // 处理关闭事件
    return odog(`处理handleclose开始: ${fname(fsPath)}`);
  };

  // 平铺函数1：创建文档
  openCustomDocument = function(uri) {
    odog(`openCustomDocument: ${uri.fsPath}`);
    return {
      // 在 CoffeeScript 中，函数最后一行自动返回
      uri: uri, // 给resolve用的uri
      dispose: function() {} // 销毁的回调
    };
  };

  
  // 平铺函数3：处理编辑器
  resolveCustomEditor = async function(webviewdoc, webviewPanel) {
    var fileId, fileName, left, leftPath, right, rightPath, tempDir;
    odog("resolveCustomEditor开始");
    odog(`resolveCustomEditor: ${webviewdoc.uri.fsPath}`);
    fileId = webviewdoc.uri.fsPath;
    webviewdic[fileId] = {webviewdoc, webviewPanel};
    fileName = fname(fileId);
    odog(`处理文件: ${fileName}`);
    updateWebview(fileId, `贱狗编辑器已打开: ${fileName}`);
    
      // 解析内容
    [right, ...left] = webviewdoc.content.split(marker);
    left = left.join(marker);
    // 创建临时文件
    tempDir = tmpdir();
    leftPath = fjoin(tempDir, `${fileName}_left.md`);
    rightPath = fjoin(tempDir, `${fileName}_right.md`);
    // leftPath =  "#{fileId}_left.md"
    // rightPath = "#{fileId}_right.md"
    // * ai说是临时目录问题. 咱们尝试下.

    // 并行异步写入两个文件
    await Promise.all([writeFileAsync(leftPath, left, 'utf8'), writeFileAsync(rightPath, right, 'utf8')]);
    odog(`创建临时文件: ${fname(leftPath)}, ${fname(rightPath)}`);
    
    // 记录活动文件
    recordfile({
      dad: fileId,
      left: leftPath,
      right: rightPath
    });
    
    // 分栏打开临时文件
    // ✅ 用数组字面量 + Promise.all
    await Promise.all([
      openEditor({
        filePath: leftPath,
        viewColumn: vscode.ViewColumn.One,
        preserveFocus: true
      }),
      openEditor({
        filePath: rightPath,
        viewColumn: vscode.ViewColumn.Two,
        preserveFocus: false
      })
    ]);
    return odog('已打开临时文件分栏');
  };

  // * 更新yefamily
  recordfile = function({dad, left, right}) {
    yefamily[left] = {
      dad,
      brother: right,
      isright: false
    };
    yefamily[right] = {
      dad,
      brother: left,
      isright: true
    };
    // * 虽然简洁, 但是, 不如上面直白
    // yefamily[s]={dad, brother:twin[1-i] } for s,i in twin
    // 记录活动文件
    return odog(`记录活动文件: ${fname(dad)}, ${fname(left)}, ${fname(right)}`);
  };

  updateWebview = function(yepath, content = null) {
    var webviewPanel, webviewdoc;
    ({webviewPanel, webviewdoc} = webviewdic[yepath]);
    if (!((webviewPanel != null) && (webviewdoc != null))) {
      odog("webviewPanel 或 webviewdoc 不存在, 无法更新");
      return;
    }
    webviewdoc.content += content != null ? content : '没有内容';
    return webviewPanel.webview.html = `<h1> 贱狗只读展示, 请于分栏编辑文件: ${fname(yepath)}</h1>
<p><small>Updated: ${new Date().toLocaleTimeString()}</small></p>
<pre>${escapeHtml(webviewdoc.content)}</pre>`;
  };

  // HTML 转义函数
  escapeHtml = function(text) {
    return text.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('"', '&quot;').replaceAll("'", '&#39;');
  };

  openEditor = async function({filePath, viewColumn, preserveFocus}) {
    var doc, editor, uri;
    odog(`openEditor打开编辑器: ${fname(filePath)}, viewColumn: ${viewColumn}, preserveFocus: ${preserveFocus}`);
    uri = vscode.Uri.file(filePath);
    doc = (await vscode.workspace.openTextDocument(uri));
    editor = (await vscode.window.showTextDocument(doc, {viewColumn, preserveFocus}));
    // 全局docdic
    docdic[filePath] = doc;
    return odog(`openEditor文件状态: ${fname(filePath)}, isDirty: ${doc.isDirty}, isUntitled: ${doc.isUntitled}`);
  };

}).call(this);
